//Cg

void vshader(float4 vtx_position : POSITION,
             float2 vtx_texcoord0 : TEXCOORD0,
             float3 vtx_normal : NORMAL,

             uniform float4x4 trans_model_to_clip_of_light,
             uniform float4x4 mat_modelproj,
             uniform float4 mspos_light,
             uniform float4 k_ambient,
             uniform float4 k_scale,
             uniform float k_push,

             out float4 l_position : POSITION,
             out float2 l_texcoord0 : TEXCOORD0,
             out float4 l_shadowcoord : TEXCOORD1,
             out float  l_smooth : TEXCOORD2,
             out float4 l_lightclip : TEXCOORD3)
{
    float4 position = vtx_position * k_scale;

    // vertex position
    l_position = mul(mat_modelproj, position);

    // Pass through texture coordinate for main texture.
    l_texcoord0 = vtx_texcoord0;

    // Calculate the surface lighting factor.
    l_smooth = saturate(dot(vtx_normal, normalize(mspos_light.xyz - position.xyz)));

    // Calculate light-space clip position.
    float4 pushed = position + float4(vtx_normal * k_push, 0);
    l_lightclip = mul(trans_model_to_clip_of_light, pushed);

    // Calculate shadow-map texture coordinates.
    l_shadowcoord = l_lightclip * float4(0.5, 0.5, 0.5, 1.0) +
                    l_lightclip.w * float4(0.5, 0.5, 0.5, 0.0);
}


void fshader(in float2 l_texcoord0 : TEXCOORD0,
             in float4 l_shadowcoord : TEXCOORD1,
             in float  l_smooth : TEXCOORD2,
             in float4 l_lightclip : TEXCOORD3,
             uniform sampler2D tex_0 : TEXUNIT0,
             uniform sampler2D k_Ldepthmap : TEXUNIT1,
             uniform float4 k_ambient,
             uniform float4 k_texDisable,
             out float4 o_color : COLOR)
{
    float3 circleoffs = float3(l_lightclip.xy / l_lightclip.w, 0);
    float falloff = saturate(1.0 - dot(circleoffs, circleoffs));
    float4 baseColor = saturate(tex2D(tex_0, l_texcoord0) + k_texDisable);
    float4 proj = l_shadowcoord / l_shadowcoord.w;
    float mapval = f1tex2D(k_Ldepthmap, proj.xy);
    float shade = (mapval > proj.z);
    o_color = baseColor * (falloff * shade * l_smooth + k_ambient.x);
}

