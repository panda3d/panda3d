cmake_minimum_required(VERSION 3.0.2)
set(CMAKE_DISABLE_SOURCE_CHANGES ON) # Must go before project() below
set(CMAKE_DISABLE_IN_SOURCE_BUILD ON) # Must go before project() below

# Figure out the version
file(STRINGS "setup.cfg" _version REGEX "^version = ")
string(REGEX REPLACE "^.*= " "" _version "${_version}")
project(Panda3D VERSION ${_version})
unset(_version)

enable_testing()

# Panda3D is now a C++11 project. Newer versions of CMake support this out of
# the box; for older versions we take a shot in the dark:
if(CMAKE_VERSION VERSION_LESS "3.1")
  include(CheckCXXCompilerFlag)
  check_cxx_compiler_flag("-std=gnu++11" COMPILER_SUPPORTS_CXX11)
  if(COMPILER_SUPPORTS_CXX11)
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=gnu++11")
  else()
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=gnu++0x")
  endif()
else()
  set(CMAKE_CXX_STANDARD 11)
endif()

# Add generic modules to cmake module path,
# and add Panda3D specific modules to cmake module path
set(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} "${CMAKE_SOURCE_DIR}/cmake/modules/")
set(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} "${CMAKE_SOURCE_DIR}/cmake/macros/")

# Set certain CMake flags we expect
set(CMAKE_INCLUDE_CURRENT_DIR_IN_INTERFACE ON)
set(CMAKE_INCLUDE_CURRENT_DIR ON)

# Set up the output directory structure, mimicking that of makepanda
set(CMAKE_BINARY_DIR "${CMAKE_BINARY_DIR}/cmake")
set(CMAKE_RUNTIME_OUTPUT_DIRECTORY "${PROJECT_BINARY_DIR}/bin")
set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY "${PROJECT_BINARY_DIR}/lib")
set(CMAKE_LIBRARY_OUTPUT_DIRECTORY "${PROJECT_BINARY_DIR}/lib")
set(MODULE_DESTINATION "lib")

# Runtime code assumes that dynamic modules have a "lib" prefix; Windows
# assumes that debug libraries have a _d suffix.
set(CMAKE_SHARED_MODULE_PREFIX "lib")
if(WIN32)
  set(CMAKE_DEBUG_POSTFIX "_d")

  # Windows uses libfoo.lib for static libraries and foo.lib/dll for dynamic.
  set(CMAKE_STATIC_LIBRARY_PREFIX "lib")

  # On Windows, modules (DLLs) are located in bin; lib is just for .lib files
  set(CMAKE_LIBRARY_OUTPUT_DIRECTORY "${PROJECT_BINARY_DIR}/bin")
  if(BUILD_SHARED_LIBS)
    set(MODULE_DESTINATION "bin")
  endif()
endif()

# Set warning levels
if(MSVC)
  set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} /W3")
  set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} /W3")
else()
  set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -Wall")
  set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wall")
endif()
if(NOT "x${CMAKE_CXX_COMPILER_ID}" STREQUAL "xMSVC")
  set(disable_flags "-Wno-unused-function -Wno-unused-parameter")
  set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} ${disable_flags}")
  set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} ${disable_flags} -Wno-reorder")
  set(CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_RELEASE} -Wno-unused-variable")
  set(CMAKE_CXX_FLAGS_RELWITHDEBINFO "${CMAKE_CXX_FLAGS_RELWITHDEBINFO} -Wno-unused-variable")
  set(CMAKE_CXX_FLAGS_MINSIZEREL "${CMAKE_CXX_FLAGS_MINSIZEREL} -Wno-unused-variable")

  if(MSVC)
    # Clang behaving as MSVC
    set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -Wno-unused-command-line-argument")
    set(CMAKE_CXX_FLAGS
      "${CMAKE_CXX_FLAGS} -Wno-microsoft-template -Wno-unused-command-line-argument")
  endif()
endif()
if(WIN32)
  add_definitions(-D_CRT_SECURE_NO_WARNINGS)
endif()

# CMake will often pass -rdynamic when linking executables as a convenience for
# projects that might forget when to use ENABLE_EXPORTS.  This is preposterous,
# since it prevents the linker from removing symbols unneeded by the executable
# and stops us from identifying cases where ENABLE_EXPORTS is needed.
set(CMAKE_SHARED_LIBRARY_LINK_C_FLAGS "")
set(CMAKE_SHARED_LIBRARY_LINK_CXX_FLAGS "")

# As long as we're figuring out compiler flags, figure out the flags for
# turning C++ exception support on and off
if(MSVC)
  set(cxx_exceptions_on "/EHsc")
  set(cxx_exceptions_off "/D_HAS_EXCEPTIONS=0")
else()
  set(cxx_exceptions_on "-fexceptions")
  set(cxx_exceptions_off "-fno-exceptions")
endif()
set(cxx_exceptions_property "$<BOOL:$<TARGET_PROPERTY:CXX_EXCEPTIONS>>")
add_compile_options(
  "$<${cxx_exceptions_property}:${cxx_exceptions_on}>"
  "$<$<NOT:${cxx_exceptions_property}>:${cxx_exceptions_off}>")

# Include global modules needed for configure scripts
include(PackageConfig)      # Defines package_option

# Configure Panda3D
include(dtool/PandaVersion.cmake)
include(dtool/Package.cmake)
include(dtool/Config.cmake)

# Include global modules
include(AddBisonTarget)     # Defines add_bison_target function
include(AddFlexTarget)      # Defines add_flex_target function
include(BuildMetalib)       # Defines add_component_library AND add_metalib
include(CompositeSources)   # Defines composite_sources function
include(Python)             # Defines add_python_target AND install_python_package
include(Interrogate)        # Defines target_interrogate AND add_python_module
include(RunPzip)            # Defines run_pzip function
include(Versioning)         # Hooks 'add_library' to apply VERSION/SOVERSION

# Add the include path for source and header files generated by CMake
include_directories("${PROJECT_BINARY_DIR}/include/${CMAKE_CFG_INTDIR}")

# Determine which trees to build.
option(BUILD_DTOOL  "Build the dtool source tree." ON)
option(BUILD_PANDA  "Build the panda source tree." ON)
option(BUILD_DIRECT "Build the direct source tree." ON)
option(BUILD_PANDATOOL "Build the pandatool source tree." ON)
option(BUILD_MODELS "Build/install the built-in models." ON)

# Include Panda3D packages
if(BUILD_DTOOL)
  add_subdirectory(dtool "${CMAKE_BINARY_DIR}/dtool")
endif()

if(BUILD_PANDA)
  add_subdirectory(panda "${CMAKE_BINARY_DIR}/panda")
endif()

if(BUILD_DIRECT)
  add_subdirectory(direct "${CMAKE_BINARY_DIR}/direct")
endif()

if(BUILD_PANDATOOL)
  add_subdirectory(pandatool "${CMAKE_BINARY_DIR}/pandatool")
endif()

if(BUILD_MODELS)
  # We don't really "build" the models, just pzip them
  file(COPY "${CMAKE_CURRENT_SOURCE_DIR}/models/maps/"
    DESTINATION "${PROJECT_BINARY_DIR}/models/maps"
  )
  run_pzip(models
    "${CMAKE_CURRENT_SOURCE_DIR}/models/"
    "${PROJECT_BINARY_DIR}/models"
    *.egg
  )
  file(COPY "${CMAKE_CURRENT_SOURCE_DIR}/dmodels/src/"
    DESTINATION "${PROJECT_BINARY_DIR}/models"
    FILES_MATCHING PATTERN *.rgb PATTERN *.png PATTERN *.jpg PATTERN *.wav
  )
  run_pzip(dmodels
    "${CMAKE_CURRENT_SOURCE_DIR}/dmodels/src/"
    "${PROJECT_BINARY_DIR}/models"
    *.egg
  )
  install(DIRECTORY "${PROJECT_BINARY_DIR}/models"
    COMPONENT Models DESTINATION share/panda3d)
endif()

if(INTERROGATE_PYTHON_INTERFACE)
  # If we built the Python interface, run the test suite.  Note, we do NOT test
  # for pytest before adding this test.  If the user doesn't have pytest, we'd
  # like for the tests to fail.

  add_test(pytest "${PYTHON_EXECUTABLE}" -m pytest "${PROJECT_SOURCE_DIR}/tests")
endif()

# Generate the Panda3DConfig.cmake file so find_package(Panda3D) works, and
# also register the build directory with CMake's package registry.

file(COPY "${PROJECT_SOURCE_DIR}/cmake/install/Panda3DConfig.cmake"
  DESTINATION "${PROJECT_BINARY_DIR}")
install(FILES "${PROJECT_SOURCE_DIR}/cmake/install/Panda3DConfig.cmake"
  DESTINATION "lib/cmake/Panda3D")

export(PACKAGE Panda3D)
