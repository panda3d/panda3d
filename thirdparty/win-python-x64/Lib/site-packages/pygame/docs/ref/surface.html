
<html>
<title>surface - Pygame Documentation</title>
<body bgcolor=#aaeebb text=#000000 link=#331111 vlink=#331111>


<table cellpadding=0 cellspacing=0 border=0 style='border: 3px solid black;' width='100%'>
<tr>
<td bgcolor='#c2fc20' style='padding: 6px;' align=center valign=center><a href='http://www.pygame.org/'><img src='../pygame_tiny.gif' border=0 width=200 height=60></a><br><b>pygame documentation</b></td>
<td bgcolor='#6aee28' style='border-left: 3px solid black; padding: 6px;' align=center valign=center>
	||&nbsp;
	<a href=http://www.pygame.org>Pygame Home</a> &nbsp;||&nbsp;
	<a href=../index.html>Help Contents</a> &nbsp;||
	<a href=index.html>Reference Index</a> &nbsp;||
	<br>&nbsp;<br>
	
<a href="camera.html">Camera</a>&nbsp;||&nbsp;
<a href="cdrom.html">Cdrom</a>&nbsp;||&nbsp;
<a href="color.html">Color</a>&nbsp;||&nbsp;
<a href="cursors.html">Cursors</a>&nbsp;||&nbsp;
<a href="display.html">Display</a>&nbsp;||&nbsp;
<a href="draw.html">Draw</a>&nbsp;||&nbsp;
<a href="event.html">Event</a>&nbsp;||&nbsp;
<a href="examples.html">Examples</a>&nbsp;||&nbsp;
<a href="font.html">Font</a>&nbsp;||&nbsp;
<a href="freetype.html">Freetype</a>&nbsp;||&nbsp;
<a href="gfxdraw.html">Gfxdraw</a>&nbsp;||&nbsp;
<a href="image.html">Image</a>&nbsp;||&nbsp;
<a href="joystick.html">Joystick</a>&nbsp;||&nbsp;
<a href="key.html">Key</a>&nbsp;||&nbsp;
<a href="locals.html">Locals</a>&nbsp;||&nbsp;
<a href="mask.html">Mask</a>&nbsp;||&nbsp;
<a href="math.html">Math</a>&nbsp;||&nbsp;
<a href="midi.html">Midi</a>&nbsp;||&nbsp;
<a href="mixer.html">Mixer</a>&nbsp;||&nbsp;
<a href="mouse.html">Mouse</a>&nbsp;||&nbsp;
<a href="movie.html">Movie</a>&nbsp;||&nbsp;
<a href="music.html">Music</a>&nbsp;||&nbsp;
<a href="overlay.html">Overlay</a>&nbsp;||&nbsp;
<a href="pixelarray.html">Pixelarray</a>&nbsp;||&nbsp;
<a href="pixelcopy.html">Pixelcopy</a>&nbsp;||&nbsp;
<a href="pygame.html">Pygame</a>&nbsp;||&nbsp;
<a href="rect.html">Rect</a>&nbsp;||&nbsp;
<a href="scrap.html">Scrap</a>&nbsp;||&nbsp;
<a href="sndarray.html">Sndarray</a>&nbsp;||&nbsp;
<a href="sprite.html">Sprite</a>&nbsp;||&nbsp;
<a href="surface.html">Surface</a>&nbsp;||&nbsp;
<a href="surfarray.html">Surfarray</a>&nbsp;||&nbsp;
<a href="tests.html">Tests</a>&nbsp;||&nbsp;
<a href="time.html">Time</a>&nbsp;||&nbsp;
<a href="transform.html">Transform</a>
</td></tr></table>
<br>


<a name="pygame.Surface">
<big><b>pygame.Surface</big></b><br><ul>
  <i>pygame object for representing images</i><br>
  <tt>pygame.Surface((width, height), flags=0, depth=0, masks=None): return Surface</tt><br>
  <tt>pygame.Surface((width, height), flags=0, Surface): return Surface</tt><br>
<ul><small><table>
  <tr><td><a href="surface.html#Surface.blit">Surface.blit</a></td><td> &mdash; draw one image onto another</td></tr>
  <tr><td><a href="surface.html#Surface.convert">Surface.convert</a></td><td> &mdash; change the pixel format of an image</td></tr>
  <tr><td><a href="surface.html#Surface.convert_alpha">Surface.convert_alpha</a></td><td> &mdash; change the pixel format of an image including per pixel alphas</td></tr>
  <tr><td><a href="surface.html#Surface.copy">Surface.copy</a></td><td> &mdash; create a new copy of a Surface</td></tr>
  <tr><td><a href="surface.html#Surface.fill">Surface.fill</a></td><td> &mdash; fill Surface with a solid color</td></tr>
  <tr><td><a href="surface.html#Surface.scroll">Surface.scroll</a></td><td> &mdash; Shift the surface image in place</td></tr>
  <tr><td><a href="surface.html#Surface.set_colorkey">Surface.set_colorkey</a></td><td> &mdash; Set the transparent colorkey</td></tr>
  <tr><td><a href="surface.html#Surface.get_colorkey">Surface.get_colorkey</a></td><td> &mdash; Get the current transparent colorkey</td></tr>
  <tr><td><a href="surface.html#Surface.set_alpha">Surface.set_alpha</a></td><td> &mdash; set the alpha value for the full Surface image</td></tr>
  <tr><td><a href="surface.html#Surface.get_alpha">Surface.get_alpha</a></td><td> &mdash; get the current Surface transparency value</td></tr>
  <tr><td><a href="surface.html#Surface.lock">Surface.lock</a></td><td> &mdash; lock the Surface memory for pixel access</td></tr>
  <tr><td><a href="surface.html#Surface.unlock">Surface.unlock</a></td><td> &mdash; unlock the Surface memory from pixel access</td></tr>
  <tr><td><a href="surface.html#Surface.mustlock">Surface.mustlock</a></td><td> &mdash; test if the Surface requires locking</td></tr>
  <tr><td><a href="surface.html#Surface.get_locked">Surface.get_locked</a></td><td> &mdash; test if the Surface is current locked</td></tr>
  <tr><td><a href="surface.html#Surface.get_locks">Surface.get_locks</a></td><td> &mdash; Gets the locks for the Surface</td></tr>
  <tr><td><a href="surface.html#Surface.get_at">Surface.get_at</a></td><td> &mdash; get the color value at a single pixel</td></tr>
  <tr><td><a href="surface.html#Surface.set_at">Surface.set_at</a></td><td> &mdash; set the color value for a single pixel</td></tr>
  <tr><td><a href="surface.html#Surface.get_at_mapped">Surface.get_at_mapped</a></td><td> &mdash; get the mapped color value at a single pixel</td></tr>
  <tr><td><a href="surface.html#Surface.get_palette">Surface.get_palette</a></td><td> &mdash; get the color index palette for an 8bit Surface</td></tr>
  <tr><td><a href="surface.html#Surface.get_palette_at">Surface.get_palette_at</a></td><td> &mdash; get the color for a single entry in a palette</td></tr>
  <tr><td><a href="surface.html#Surface.set_palette">Surface.set_palette</a></td><td> &mdash; set the color palette for an 8bit Surface</td></tr>
  <tr><td><a href="surface.html#Surface.set_palette_at">Surface.set_palette_at</a></td><td> &mdash; set the color for a single index in an 8bit Surface palette</td></tr>
  <tr><td><a href="surface.html#Surface.map_rgb">Surface.map_rgb</a></td><td> &mdash; convert a color into a mapped color value</td></tr>
  <tr><td><a href="surface.html#Surface.unmap_rgb">Surface.unmap_rgb</a></td><td> &mdash; convert a mapped integer color value into a Color</td></tr>
  <tr><td><a href="surface.html#Surface.set_clip">Surface.set_clip</a></td><td> &mdash; set the current clipping area of the Surface</td></tr>
  <tr><td><a href="surface.html#Surface.get_clip">Surface.get_clip</a></td><td> &mdash; get the current clipping area of the Surface</td></tr>
  <tr><td><a href="surface.html#Surface.subsurface">Surface.subsurface</a></td><td> &mdash; create a new surface that references its parent</td></tr>
  <tr><td><a href="surface.html#Surface.get_parent">Surface.get_parent</a></td><td> &mdash; find the parent of a subsurface</td></tr>
  <tr><td><a href="surface.html#Surface.get_abs_parent">Surface.get_abs_parent</a></td><td> &mdash; find the top level parent of a subsurface</td></tr>
  <tr><td><a href="surface.html#Surface.get_offset">Surface.get_offset</a></td><td> &mdash; find the position of a child subsurface inside a parent</td></tr>
  <tr><td><a href="surface.html#Surface.get_abs_offset">Surface.get_abs_offset</a></td><td> &mdash; find the absolute position of a child subsurface inside its top level parent</td></tr>
  <tr><td><a href="surface.html#Surface.get_size">Surface.get_size</a></td><td> &mdash; get the dimensions of the Surface</td></tr>
  <tr><td><a href="surface.html#Surface.get_width">Surface.get_width</a></td><td> &mdash; get the width of the Surface</td></tr>
  <tr><td><a href="surface.html#Surface.get_height">Surface.get_height</a></td><td> &mdash; get the height of the Surface</td></tr>
  <tr><td><a href="surface.html#Surface.get_rect">Surface.get_rect</a></td><td> &mdash; get the rectangular area of the Surface</td></tr>
  <tr><td><a href="surface.html#Surface.get_bitsize">Surface.get_bitsize</a></td><td> &mdash; get the bit depth of the Surface pixel format</td></tr>
  <tr><td><a href="surface.html#Surface.get_bytesize">Surface.get_bytesize</a></td><td> &mdash; get the bytes used per Surface pixel</td></tr>
  <tr><td><a href="surface.html#Surface.get_flags">Surface.get_flags</a></td><td> &mdash; get the additional flags used for the Surface</td></tr>
  <tr><td><a href="surface.html#Surface.get_pitch">Surface.get_pitch</a></td><td> &mdash; get the number of bytes used per Surface row</td></tr>
  <tr><td><a href="surface.html#Surface.get_masks">Surface.get_masks</a></td><td> &mdash; the bitmasks needed to convert between a color and a mapped integer</td></tr>
  <tr><td><a href="surface.html#Surface.set_masks">Surface.set_masks</a></td><td> &mdash; set the bitmasks needed to convert between a color and a mapped integer</td></tr>
  <tr><td><a href="surface.html#Surface.get_shifts">Surface.get_shifts</a></td><td> &mdash; the bit shifts needed to convert between a color and a mapped integer</td></tr>
  <tr><td><a href="surface.html#Surface.set_shifts">Surface.set_shifts</a></td><td> &mdash; sets the bit shifts needed to convert between a color and a mapped integer</td></tr>
  <tr><td><a href="surface.html#Surface.get_losses">Surface.get_losses</a></td><td> &mdash; the significant bits used to convert between a color and a mapped integer</td></tr>
  <tr><td><a href="surface.html#Surface.get_bounding_rect">Surface.get_bounding_rect</a></td><td> &mdash; find the smallest rect containing data</td></tr>
  <tr><td><a href="surface.html#Surface.get_view">Surface.get_view</a></td><td> &mdash; return a view of a surface's pixel data.</td></tr>
  <tr><td><a href="surface.html#Surface.get_buffer">Surface.get_buffer</a></td><td> &mdash; acquires a buffer object for the pixels of the Surface.</td></tr>
</table></small></ul>
<p>A pygame Surface is used to represent any image. The Surface has a fixed resolution and pixel format. Surfaces with 8bit pixels use a color palette to map to 24bit color. </p>
<p>Call <tt><a href="surface.html#pygame.Surface">pygame.Surface</a></tt>&nbsp;&ndash;<font size=-1>pygame object for representing images</font>&ndash; to create a new image object. The Surface will be cleared to all black. The only required arguments are the sizes. With no additional arguments, the Surface will be created in a format that best matches the display Surface. </p>
<p>The pixel format can be controlled by passing the bit depth or an existing Surface. The flags argument is a bitmask of additional features for the surface. You can pass any combination of these flags: </p>
<pre>  HWSURFACE, creates the image in video memory
  SRCALPHA, the pixel format will include a per-pixel alpha
</pre><p>Both flags are only a request, and may not be possible for all displays and formats. </p>
<p>Advance users can combine a set of bitmasks with a depth value. The masks are a set of 4 integers representing which bits in a pixel will represent each color. Normal Surfaces should not require the masks argument. </p>
<p>Surfaces can have many extra attributes like alpha planes, colorkeys, source rectangle clipping. These functions mainly effect how the Surface is blitted to other Surfaces. The blit routines will attempt to use hardware acceleration when possible, otherwise they will use highly optimized software blitting methods. </p>
<p>There are three types of transparency supported in Pygame: colorkeys, surface alphas, and pixel alphas. Surface alphas can be mixed with colorkeys, but an image with per pixel alphas cannot use the other modes. Colorkey transparency makes a single color value transparent. Any pixels matching the colorkey will not be drawn. The surface alpha value is a single value that changes the transparency for the entire image. A surface alpha of 255 is opaque, and a value of 0 is completely transparent. </p>
<p>Per pixel alphas are different because they store a transparency value for every pixel. This allows for the most precise transparency effects, but it also the slowest. Per pixel alphas cannot be mixed with surface alpha and colorkeys. </p>
<p>There is support for pixel access for the Surfaces. Pixel access on hardware surfaces is slow and not recommended. Pixels can be accessed using the <tt>get_at()</tt> and <tt>set_at()</tt> functions. These methods are fine for simple access, but will be considerably slow when doing of pixel work with them. If you plan on doing a lot of pixel level work, it is recommended to use the <tt>pygame.surfarray</tt> module, which can treat the surfaces like large multidimensional arrays (and it's quite quick). </p>
<p>Any functions that directly access a surface's pixel data will need that surface to be lock()'ed. These functions can <tt>lock()</tt> and <tt>unlock()</tt> the surfaces themselves without assistance. But, if a function will be called many times, there will be a lot of overhead for multiple locking and unlocking of the surface. It is best to lock the surface manually before making the function call many times, and then unlocking when you are finished. All functions that need a locked surface will say so in their docs. Remember to leave the Surface locked only while necessary. </p>
<p>Surface pixels are stored internally as a single number that has all the colors encoded into it. Use the <tt><a href="surface.html#Surface.map_rgb">Surface.map_rgb</a></tt>&nbsp;&ndash;<font size=-1>convert a color into a mapped color value</font>&ndash; and <tt><a href="surface.html#Surface.unmap_rgb">Surface.unmap_rgb</a></tt>&nbsp;&ndash;<font size=-1>convert a mapped integer color value into a Color</font>&ndash; to convert between individual red, green, and blue values into a packed integer for that Surface. </p>
<p>Surfaces can also reference sections of other Surfaces. These are created with the <tt><a href="surface.html#Surface.subsurface">Surface.subsurface</a></tt>&nbsp;&ndash;<font size=-1>create a new surface that references its parent</font>&ndash; method. Any change to either Surface will effect the other. </p>
<p>Each Surface contains a clipping area. By default the clip area covers the entire Surface. If it is changed, all drawing operations will only effect the smaller area. </p>
<!--COMMENTS:pygame.Surface--> &nbsp;<br> 


<a name="Surface.blit">
<big><b>Surface.blit</big></b><br><ul>
  <i>draw one image onto another</i><br>
  <tt>Surface.blit(source, dest, area=None, special_flags = 0): return Rect</tt><br>
<p>Draws a source Surface onto this Surface. The draw can be positioned with the dest argument. Dest can either be pair of coordinates representing the upper left corner of the source. A Rect can also be passed as the destination and the topleft corner of the rectangle will be used as the position for the blit. The size of the destination rectangle does not effect the blit. </p>
<p>An optional area rectangle can be passed as well. This represents a smaller portion of the source Surface to draw. </p>
<p>An optional special flags is for passing in new in 1.8.0: BLEND_ADD, BLEND_SUB, BLEND_MULT, BLEND_MIN, <tt>BLEND_MAX</tt> new in 1.8.1: BLEND_RGBA_ADD, BLEND_RGBA_SUB, BLEND_RGBA_MULT, BLEND_RGBA_MIN, <tt>BLEND_RGBA_MAX</tt> BLEND_RGB_ADD, BLEND_RGB_SUB, BLEND_RGB_MULT, BLEND_RGB_MIN, <tt>BLEND_RGB_MAX</tt> With other special blitting flags perhaps added in the future. </p>
<p>The return rectangle is the area of the affected pixels, excluding any pixels outside the destination Surface, or outside the clipping area. </p>
<p>Pixel alphas will be ignored when blitting to an 8 bit Surface. </p>
<p>special_flags new in pygame 1.8. </p>
<p>For a surface with colorkey or blanket alpha, a blit to self may give slightly different colors than a non self-blit. </p>
<!--COMMENTS:Surface.blit--> &nbsp;<br> 
<br></ul>


<a name="Surface.convert">
<big><b>Surface.convert</big></b><br><ul>
  <i>change the pixel format of an image</i><br>
  <tt>Surface.convert(Surface): return Surface</tt><br>
  <tt>Surface.convert(depth, flags=0): return Surface</tt><br>
  <tt>Surface.convert(masks, flags=0): return Surface</tt><br>
  <tt>Surface.convert(): return Surface</tt><br>
<p>Creates a new copy of the Surface with the pixel format changed. The new pixel format can be determined from another existing Surface. Otherwise depth, flags, and masks arguments can be used, similar to the <tt><a href="surface.html#pygame.Surface">pygame.Surface</a></tt>&nbsp;&ndash;<font size=-1>pygame object for representing images</font>&ndash; call. </p>
<p>If no arguments are passed the new Surface will have the same pixel format as the display Surface. This is always the fastest format for blitting. It is a good idea to convert all Surfaces before they are blitted many times. </p>
<p>The converted Surface will have no pixel alphas. They will be stripped if the original had them. See <tt><a href="surface.html#Surface.convert_alpha">Surface.convert_alpha</a></tt>&nbsp;&ndash;<font size=-1>change the pixel format of an image including per pixel alphas</font>&ndash; for preserving or creating per-pixel alphas. </p>
<!--COMMENTS:Surface.convert--> &nbsp;<br> 
<br></ul>


<a name="Surface.convert_alpha">
<big><b>Surface.convert_alpha</big></b><br><ul>
  <i>change the pixel format of an image including per pixel alphas</i><br>
  <tt>Surface.convert_alpha(Surface): return Surface</tt><br>
  <tt>Surface.convert_alpha(): return Surface</tt><br>
<p>Creates a new copy of the surface with the desired pixel format. The new surface will be in a format suited for quick blitting to the given format with per pixel alpha. If no surface is given, the new surface will be optimized for blitting to the current display. </p>
<p>Unlike the <tt><a href="surface.html#Surface.convert">Surface.convert</a></tt>&nbsp;&ndash;<font size=-1>change the pixel format of an image</font>&ndash; method, the pixel format for the new image will not be exactly the same as the requested source, but it will be optimized for fast alpha blitting to the destination. </p>
<!--COMMENTS:Surface.convert_alpha--> &nbsp;<br> 
<br></ul>


<a name="Surface.copy">
<big><b>Surface.copy</big></b><br><ul>
  <i>create a new copy of a Surface</i><br>
  <tt>Surface.copy(): return Surface</tt><br>
<p>Makes a duplicate copy of a Surface. The new Surface will have the same pixel formats, color palettes, and transparency settings as the original. </p>
<!--COMMENTS:Surface.copy--> &nbsp;<br> 
<br></ul>


<a name="Surface.fill">
<big><b>Surface.fill</big></b><br><ul>
  <i>fill Surface with a solid color</i><br>
  <tt>Surface.fill(color, rect=None, special_flags=0): return Rect</tt><br>
<p>Fill the Surface with a solid color. If no rect argument is given the entire Surface will be filled. The rect argument will limit the fill to a specific area. The fill will also be contained by the Surface clip area. </p>
<p>The color argument can be either a <tt>RGB</tt> sequence, a <tt>RGBA</tt> sequence or a mapped color index. If using RGBA, the Alpha (A part of RGBA) is ignored unless the surface uses per pixel alpha (Surface has the <tt>SRCALPHA</tt> flag). </p>
<p>An optional special_flags is for passing in new in 1.8.0: BLEND_ADD, BLEND_SUB, BLEND_MULT, BLEND_MIN, <tt>BLEND_MAX</tt> new in 1.8.1: BLEND_RGBA_ADD, BLEND_RGBA_SUB, BLEND_RGBA_MULT, BLEND_RGBA_MIN, <tt>BLEND_RGBA_MAX</tt> BLEND_RGB_ADD, BLEND_RGB_SUB, BLEND_RGB_MULT, BLEND_RGB_MIN, <tt>BLEND_RGB_MAX</tt> With other special blitting flags perhaps added in the future. </p>
<p>This will return the affected Surface area. </p>
<!--COMMENTS:Surface.fill--> &nbsp;<br> 
<br></ul>


<a name="Surface.scroll">
<big><b>Surface.scroll</big></b><br><ul>
  <i>Shift the surface image in place</i><br>
  <tt>Surface.scroll(dx=0, dy=0): return None</tt><br>
<p>Move the image by dx pixels right and dy pixels down. dx and dy may be negative for left and up scrolls respectively. Areas of the surface that are not overwritten retain their original pixel values. Scrolling is contained by the Surface clip area. It is safe to have dx and dy values that exceed the surface size. </p>
<p>New in Pygame 1.9 </p>
<!--COMMENTS:Surface.scroll--> &nbsp;<br> 
<br></ul>


<a name="Surface.set_colorkey">
<big><b>Surface.set_colorkey</big></b><br><ul>
  <i>Set the transparent colorkey</i><br>
  <tt>Surface.set_colorkey(Color, flags=0): return None</tt><br>
  <tt>Surface.set_colorkey(None): return None</tt><br>
<p>Set the current color key for the Surface. When blitting this Surface onto a destination, and pixels that have the same color as the colorkey will be transparent. The color can be an <tt>RGB</tt> color or a mapped color integer. If None is passed, the colorkey will be unset. </p>
<p>The colorkey will be ignored if the Surface is formatted to use per pixel alpha values. The colorkey can be mixed with the full Surface alpha value. </p>
<p>The optional flags argument can be set to <tt>pygame.RLEACCEL</tt> to provide better performance on non accelerated displays. An <tt>RLEACCEL</tt> Surface will be slower to modify, but quicker to blit as a source. </p>
<!--COMMENTS:Surface.set_colorkey--> &nbsp;<br> 
<br></ul>


<a name="Surface.get_colorkey">
<big><b>Surface.get_colorkey</big></b><br><ul>
  <i>Get the current transparent colorkey</i><br>
  <tt>Surface.get_colorkey(): return RGB or None</tt><br>
<p>Return the current colorkey value for the Surface. If the colorkey is not set then None is returned. </p>
<!--COMMENTS:Surface.get_colorkey--> &nbsp;<br> 
<br></ul>


<a name="Surface.set_alpha">
<big><b>Surface.set_alpha</big></b><br><ul>
  <i>set the alpha value for the full Surface image</i><br>
  <tt>Surface.set_alpha(value, flags=0): return None</tt><br>
  <tt>Surface.set_alpha(None): return None</tt><br>
<p>Set the current alpha value fo r the Surface. When blitting this Surface onto a destination, the pixels will be drawn slightly transparent. The alpha value is an integer from 0 to 255, 0 is fully transparent and 255 is fully opaque. If None is passed for the alpha value, then the Surface alpha will be disabled. </p>
<p>This value is different than the per pixel Surface alpha. If the Surface format contains per pixel alphas, then this alpha value will be ignored. If the Surface contains per pixel alphas, setting the alpha value to None will disable the per pixel transparency. </p>
<p>The optional flags argument can be set to <tt>pygame.RLEACCEL</tt> to provide better performance on non accelerated displays. An <tt>RLEACCEL</tt> Surface will be slower to modify, but quicker to blit as a source. </p>
<!--COMMENTS:Surface.set_alpha--> &nbsp;<br> 
<br></ul>


<a name="Surface.get_alpha">
<big><b>Surface.get_alpha</big></b><br><ul>
  <i>get the current Surface transparency value</i><br>
  <tt>Surface.get_alpha(): return int_value or None</tt><br>
<p>Return the current alpha value for the Surface. If the alpha value is not set then None is returned. </p>
<!--COMMENTS:Surface.get_alpha--> &nbsp;<br> 
<br></ul>


<a name="Surface.lock">
<big><b>Surface.lock</big></b><br><ul>
  <i>lock the Surface memory for pixel access</i><br>
  <tt>Surface.lock(): return None</tt><br>
<p>Lock the pixel data of a Surface for access. On accelerated Surfaces, the pixel data may be stored in volatile video memory or nonlinear compressed forms. When a Surface is locked the pixel memory becomes available to access by regular software. Code that reads or writes pixel values will need the Surface to be locked. </p>
<p>Surfaces should not remain locked for more than necessary. A locked Surface can often not be displayed or managed by Pygame. </p>
<p>Not all Surfaces require locking. The <tt><a href="surface.html#Surface.mustlock">Surface.mustlock</a></tt>&nbsp;&ndash;<font size=-1>test if the Surface requires locking</font>&ndash; method can determine if it is actually required. There is no performance penalty for locking and unlocking a Surface that does not need it. </p>
<p>All pygame functions will automatically lock and unlock the Surface data as needed. If a section of code is going to make calls that will repeatedly lock and unlock the Surface many times, it can be helpful to wrap the block inside a lock and unlock pair. </p>
<p>It is safe to nest locking and unlocking calls. The surface will only be unlocked after the final lock is released. </p>
<!--COMMENTS:Surface.lock--> &nbsp;<br> 
<br></ul>


<a name="Surface.unlock">
<big><b>Surface.unlock</big></b><br><ul>
  <i>unlock the Surface memory from pixel access</i><br>
  <tt>Surface.unlock(): return None</tt><br>
<p>Unlock the Surface pixel data after it has been locked. The unlocked Surface can once again be drawn and managed by Pygame. See the <tt><a href="surface.html#Surface.lock">Surface.lock</a></tt>&nbsp;&ndash;<font size=-1>lock the Surface memory for pixel access</font>&ndash; documentation for more details. </p>
<p>All pygame functions will automatically lock and unlock the Surface data as needed. If a section of code is going to make calls that will repeatedly lock and unlock the Surface many times, it can be helpful to wrap the block inside a lock and unlock pair. </p>
<p>It is safe to nest locking and unlocking calls. The surface will only be unlocked after the final lock is released. </p>
<!--COMMENTS:Surface.unlock--> &nbsp;<br> 
<br></ul>


<a name="Surface.mustlock">
<big><b>Surface.mustlock</big></b><br><ul>
  <i>test if the Surface requires locking</i><br>
  <tt>Surface.mustlock(): return bool</tt><br>
<p>Returns True if the Surface is required to be locked to access pixel data. Usually pure software Surfaces do not require locking. This method is rarely needed, since it is safe and quickest to just lock all Surfaces as needed. </p>
<p>All pygame functions will automatically lock and unlock the Surface data as needed. If a section of code is going to make calls that will repeatedly lock and unlock the Surface many times, it can be helpful to wrap the block inside a lock and unlock pair. </p>
<!--COMMENTS:Surface.mustlock--> &nbsp;<br> 
<br></ul>


<a name="Surface.get_locked">
<big><b>Surface.get_locked</big></b><br><ul>
  <i>test if the Surface is current locked</i><br>
  <tt>Surface.get_locked(): return bool</tt><br>
<p>Returns True when the Surface is locked. It doesn't matter how many times the Surface is locked. </p>
<!--COMMENTS:Surface.get_locked--> &nbsp;<br> 
<br></ul>


<a name="Surface.get_locks">
<big><b>Surface.get_locks</big></b><br><ul>
  <i>Gets the locks for the Surface</i><br>
  <tt>Surface.get_locks(): return tuple</tt><br>
<p>Returns the currently existing locks for the Surface. </p>
<!--COMMENTS:Surface.get_locks--> &nbsp;<br> 
<br></ul>


<a name="Surface.get_at">
<big><b>Surface.get_at</big></b><br><ul>
  <i>get the color value at a single pixel</i><br>
  <tt>Surface.get_at((x, y)): return Color</tt><br>
<p>Return a copy of the <tt>RGBA</tt> Color value at the given pixel. If the Surface has no per pixel alpha, then the alpha value will always be 255 (opaque). If the pixel position is outside the area of the Surface an IndexError exception will be raised. </p>
<p>Getting and setting pixels one at a time is generally too slow to be used in a game or realtime situation. It is better to use methods which operate on many pixels at a time like with the blit, fill and draw methods - or by using surfarray/PixelArray. </p>
<p>This function will temporarily lock and unlock the Surface as needed. </p>
<p>Returning a Color instead of tuple, New in pygame 1.9.0. Use <tt>tuple(surf.get_at((x,y)))</tt> if you want a tuple, and not a Color. This should only matter if you want to use the color as a key in a dict. </p>
<!--COMMENTS:Surface.get_at--> &nbsp;<br> 
<br></ul>


<a name="Surface.set_at">
<big><b>Surface.set_at</big></b><br><ul>
  <i>set the color value for a single pixel</i><br>
  <tt>Surface.set_at((x, y), Color): return None</tt><br>
<p>Set the <tt>RGBA</tt> or mapped integer color value for a single pixel. If the Surface does not have per pixel alphas, the alpha value is ignored. Settting pixels outside the Surface area or outside the Surface clipping will have no effect. </p>
<p>Getting and setting pixels one at a time is generally too slow to be used in a game or realtime situation. </p>
<p>This function will temporarily lock and unlock the Surface as needed. </p>
<!--COMMENTS:Surface.set_at--> &nbsp;<br> 
<br></ul>


<a name="Surface.get_at_mapped">
<big><b>Surface.get_at_mapped</big></b><br><ul>
  <i>get the mapped color value at a single pixel</i><br>
  <tt>Surface.get_at_mapped((x, y)): return Color</tt><br>
<p>Return the integer value of the given pixel. If the pixel position is outside the area of the Surface an IndexError exception will be raised. </p>
<p>This method is intended for Pygame unit testing. It unlikely has any use in an application. </p>
<p>This function will temporarily lock and unlock the Surface as needed. </p>
<p>New in pygame. 1.9.2. </p>
<!--COMMENTS:Surface.get_at_mapped--> &nbsp;<br> 
<br></ul>


<a name="Surface.get_palette">
<big><b>Surface.get_palette</big></b><br><ul>
  <i>get the color index palette for an 8bit Surface</i><br>
  <tt>Surface.get_palette(): return [RGB, RGB, RGB, ...]</tt><br>
<p>Return a list of up to 256 color elements that represent the indexed colors used in an 8bit Surface. The returned list is a copy of the palette, and changes will have no effect on the Surface. </p>
<p>Returning a list of <tt>Color(with length 3)</tt> instances instead of tuples, New in pygame 1.9.0 </p>
<!--COMMENTS:Surface.get_palette--> &nbsp;<br> 
<br></ul>


<a name="Surface.get_palette_at">
<big><b>Surface.get_palette_at</big></b><br><ul>
  <i>get the color for a single entry in a palette</i><br>
  <tt>Surface.get_palette_at(index): return RGB</tt><br>
<p>Returns the red, green, and blue color values for a single index in a Surface palette. The index should be a value from 0 to 255. </p>
<p>Returning <tt>Color(with length 3)</tt> instance instead of a tuple, New in pygame 1.9.0 </p>
<!--COMMENTS:Surface.get_palette_at--> &nbsp;<br> 
<br></ul>


<a name="Surface.set_palette">
<big><b>Surface.set_palette</big></b><br><ul>
  <i>set the color palette for an 8bit Surface</i><br>
  <tt>Surface.set_palette([RGB, RGB, RGB, ...]): return None</tt><br>
<p>Set the full palette for an 8bit Surface. This will replace the colors in the existing palette. A partial palette can be passed and only the first colors in the original palette will be changed. </p>
<p>This function has no effect on a Surface with more than 8bits per pixel. </p>
<!--COMMENTS:Surface.set_palette--> &nbsp;<br> 
<br></ul>


<a name="Surface.set_palette_at">
<big><b>Surface.set_palette_at</big></b><br><ul>
  <i>set the color for a single index in an 8bit Surface palette</i><br>
  <tt>Surface.set_palette_at(index, RGB): return None</tt><br>
<p>Set the palette value for a single entry in a Surface palette. The index should be a value from 0 to 255. </p>
<p>This function has no effect on a Surface with more than 8bits per pixel. </p>
<!--COMMENTS:Surface.set_palette_at--> &nbsp;<br> 
<br></ul>


<a name="Surface.map_rgb">
<big><b>Surface.map_rgb</big></b><br><ul>
  <i>convert a color into a mapped color value</i><br>
  <tt>Surface.map_rgb(Color): return mapped_int</tt><br>
<p>Convert an <tt>RGBA</tt> color into the mapped integer value for this Surface. The returned integer will contain no more bits than the bit depth of the Surface. Mapped color values are not often used inside Pygame, but can be passed to most functions that require a Surface and a color. </p>
<p>See the Surface object documentation for more information about colors and pixel formats. </p>
<!--COMMENTS:Surface.map_rgb--> &nbsp;<br> 
<br></ul>


<a name="Surface.unmap_rgb">
<big><b>Surface.unmap_rgb</big></b><br><ul>
  <i>convert a mapped integer color value into a Color</i><br>
  <tt>Surface.unmap_rgb(mapped_int): return Color</tt><br>
<p>Convert an mapped integer color into the <tt>RGB</tt> color components for this Surface. Mapped color values are not often used inside Pygame, but can be passed to most functions that require a Surface and a color. </p>
<p>See the Surface object documentation for more information about colors and pixel formats. </p>
<!--COMMENTS:Surface.unmap_rgb--> &nbsp;<br> 
<br></ul>


<a name="Surface.set_clip">
<big><b>Surface.set_clip</big></b><br><ul>
  <i>set the current clipping area of the Surface</i><br>
  <tt>Surface.set_clip(rect): return None</tt><br>
  <tt>Surface.set_clip(None): return None</tt><br>
<p>Each Surface has an active clipping area. This is a rectangle that represents the only pixels on the Surface that can be modified. If None is passed for the rectangle the full Surface will be available for changes. </p>
<p>The clipping area is always restricted to the area of the Surface itself. If the clip rectangle is too large it will be shrunk to fit inside the Surface. </p>
<!--COMMENTS:Surface.set_clip--> &nbsp;<br> 
<br></ul>


<a name="Surface.get_clip">
<big><b>Surface.get_clip</big></b><br><ul>
  <i>get the current clipping area of the Surface</i><br>
  <tt>Surface.get_clip(): return Rect</tt><br>
<p>Return a rectangle of the current clipping area. The Surface will always return a valid rectangle that will never be outside the bounds of the image. If the Surface has had None set for the clipping area, the Surface will return a rectangle with the full area of the Surface. </p>
<!--COMMENTS:Surface.get_clip--> &nbsp;<br> 
<br></ul>


<a name="Surface.subsurface">
<big><b>Surface.subsurface</big></b><br><ul>
  <i>create a new surface that references its parent</i><br>
  <tt>Surface.subsurface(Rect): return Surface</tt><br>
<p>Returns a new Surface that shares its pixels with its new parent. The new Surface is considered a child of the original. Modifications to either Surface pixels will effect each other. Surface information like clipping area and color keys are unique to each Surface. </p>
<p>The new Surface will inherit the palette, color key, and alpha settings from its parent. </p>
<p>It is possible to have any number of subsurfaces and subsubsurfaces on the parent. It is also possible to subsurface the display Surface if the display mode is not hardware accelerated. </p>
<p>See the <tt><a href="surface.html#Surface.get_offset">Surface.get_offset</a></tt>&nbsp;&ndash;<font size=-1>find the position of a child subsurface inside a parent</font>, <tt><a href="surface.html#Surface.get_parent">Surface.get_parent</a></tt>&nbsp;&ndash;<font size=-1>find the parent of a subsurface</font>&ndash; to learn more about the state of a subsurface. </p>
<!--COMMENTS:Surface.subsurface--> &nbsp;<br> 
<br></ul>


<a name="Surface.get_parent">
<big><b>Surface.get_parent</big></b><br><ul>
  <i>find the parent of a subsurface</i><br>
  <tt>Surface.get_parent(): return Surface</tt><br>
<p>Returns the parent Surface of a subsurface. If this is not a subsurface then None will be returned. </p>
<!--COMMENTS:Surface.get_parent--> &nbsp;<br> 
<br></ul>


<a name="Surface.get_abs_parent">
<big><b>Surface.get_abs_parent</big></b><br><ul>
  <i>find the top level parent of a subsurface</i><br>
  <tt>Surface.get_abs_parent(): return Surface</tt><br>
<p>Returns the parent Surface of a subsurface. If this is not a subsurface then this surface will be returned. </p>
<!--COMMENTS:Surface.get_abs_parent--> &nbsp;<br> 
<br></ul>


<a name="Surface.get_offset">
<big><b>Surface.get_offset</big></b><br><ul>
  <i>find the position of a child subsurface inside a parent</i><br>
  <tt>Surface.get_offset(): return (x, y)</tt><br>
<p>Get the offset position of a child subsurface inside of a parent. If the Surface is not a subsurface this will return (0, 0). </p>
<!--COMMENTS:Surface.get_offset--> &nbsp;<br> 
<br></ul>


<a name="Surface.get_abs_offset">
<big><b>Surface.get_abs_offset</big></b><br><ul>
  <i>find the absolute position of a child subsurface inside its top level parent</i><br>
  <tt>Surface.get_abs_offset(): return (x, y)</tt><br>
<p>Get the offset position of a child subsurface inside of its top level parent Surface. If the Surface is not a subsurface this will return (0, 0). </p>
<!--COMMENTS:Surface.get_abs_offset--> &nbsp;<br> 
<br></ul>


<a name="Surface.get_size">
<big><b>Surface.get_size</big></b><br><ul>
  <i>get the dimensions of the Surface</i><br>
  <tt>Surface.get_size(): return (width, height)</tt><br>
<p>Return the width and height of the Surface in pixels. </p>
<!--COMMENTS:Surface.get_size--> &nbsp;<br> 
<br></ul>


<a name="Surface.get_width">
<big><b>Surface.get_width</big></b><br><ul>
  <i>get the width of the Surface</i><br>
  <tt>Surface.get_width(): return width</tt><br>
<p>Return the width of the Surface in pixels. </p>
<!--COMMENTS:Surface.get_width--> &nbsp;<br> 
<br></ul>


<a name="Surface.get_height">
<big><b>Surface.get_height</big></b><br><ul>
  <i>get the height of the Surface</i><br>
  <tt>Surface.get_height(): return height</tt><br>
<p>Return the height of the Surface in pixels. </p>
<!--COMMENTS:Surface.get_height--> &nbsp;<br> 
<br></ul>


<a name="Surface.get_rect">
<big><b>Surface.get_rect</big></b><br><ul>
  <i>get the rectangular area of the Surface</i><br>
  <tt>Surface.get_rect(**kwargs): return Rect</tt><br>
<p>Returns a new rectangle covering the entire surface. This rectangle will always start at 0, 0 with a width. and height the same size as the image. </p>
<p>You can pass keyword argument values to this function. These named values will be applied to the attributes of the Rect before it is returned. An example would be 'mysurf.get_rect(center=(100,100))' to create a rectangle for the Surface centered at a given position. </p>
<!--COMMENTS:Surface.get_rect--> &nbsp;<br> 
<br></ul>


<a name="Surface.get_bitsize">
<big><b>Surface.get_bitsize</big></b><br><ul>
  <i>get the bit depth of the Surface pixel format</i><br>
  <tt>Surface.get_bitsize(): return int</tt><br>
<p>Returns the number of bits used to represent each pixel. This value may not exactly fill the number of bytes used per pixel. For example a 15 bit Surface still requires a full 2 bytes. </p>
<!--COMMENTS:Surface.get_bitsize--> &nbsp;<br> 
<br></ul>


<a name="Surface.get_bytesize">
<big><b>Surface.get_bytesize</big></b><br><ul>
  <i>get the bytes used per Surface pixel</i><br>
  <tt>Surface.get_bytesize(): return int</tt><br>
<p>Return the number of bytes used per pixel. </p>
<!--COMMENTS:Surface.get_bytesize--> &nbsp;<br> 
<br></ul>


<a name="Surface.get_flags">
<big><b>Surface.get_flags</big></b><br><ul>
  <i>get the additional flags used for the Surface</i><br>
  <tt>Surface.get_flags(): return int</tt><br>
<p>Returns a set of current Surface features. Each feature is a bit in the flags bitmask. Typical flags are HWSURFACE, RLEACCEL, SRCALPHA, and <tt>SRCCOLORKEY</tt>. </p>
<p>Here is a more complete list of flags. A full list can be found in <tt>SDL_video.h</tt> </p>
<pre>  SWSURFACE	0x00000000	# Surface is in system memory
  HWSURFACE	0x00000001	# Surface is in video memory
  ASYNCBLIT	0x00000004	# Use asynchronous blits if possible
</pre><p>Available for <tt><a href="display.html#pygame.display.set_mode">pygame.display.set_mode</a></tt>&nbsp;&ndash;<font size=-1>initialize a window or screen for display</font>&ndash; </p>
<pre>  ANYFORMAT	0x10000000	# Allow any video depth/pixel-format
  HWPALETTE	0x20000000	# Surface has exclusive palette
  DOUBLEBUF	0x40000000	# Set up double-buffered video mode
  FULLSCREEN	0x80000000	# Surface is a full screen display
  OPENGL        0x00000002      # Create an OpenGL rendering context
  OPENGLBLIT	0x0000000A	# Create an OpenGL rendering context
                                #   and use it for blitting.  Obsolete.
  RESIZABLE	0x00000010	# This video mode may be resized
  NOFRAME       0x00000020	# No window caption or edge frame
</pre><p>Used internally (read-only) </p>
<pre>  HWACCEL       0x00000100	# Blit uses hardware acceleration
  SRCCOLORKEY	0x00001000	# Blit uses a source color key
  RLEACCELOK	0x00002000	# Private flag
  RLEACCEL	0x00004000	# Surface is RLE encoded
  SRCALPHA	0x00010000	# Blit uses source alpha blending
  PREALLOC	0x01000000	# Surface uses preallocated memory
</pre>
<!--COMMENTS:Surface.get_flags--> &nbsp;<br> 
<br></ul>


<a name="Surface.get_pitch">
<big><b>Surface.get_pitch</big></b><br><ul>
  <i>get the number of bytes used per Surface row</i><br>
  <tt>Surface.get_pitch(): return int</tt><br>
<p>Return the number of bytes separating each row in the Surface. Surfaces in video memory are not always linearly packed. Subsurfaces will also have a larger pitch than their real width. </p>
<p>This value is not needed for normal Pygame usage. </p>
<!--COMMENTS:Surface.get_pitch--> &nbsp;<br> 
<br></ul>


<a name="Surface.get_masks">
<big><b>Surface.get_masks</big></b><br><ul>
  <i>the bitmasks needed to convert between a color and a mapped integer</i><br>
  <tt>Surface.get_masks(): return (R, G, B, A)</tt><br>
<p>Returns the bitmasks used to isolate each color in a mapped integer. </p>
<p>This value is not needed for normal Pygame usage. </p>
<!--COMMENTS:Surface.get_masks--> &nbsp;<br> 
<br></ul>


<a name="Surface.set_masks">
<big><b>Surface.set_masks</big></b><br><ul>
  <i>set the bitmasks needed to convert between a color and a mapped integer</i><br>
  <tt>Surface.set_masks((r,g,b,a)): return None</tt><br>
<p>This is not needed for normal Pygame usage. New in pygame 1.8.1 </p>
<!--COMMENTS:Surface.set_masks--> &nbsp;<br> 
<br></ul>


<a name="Surface.get_shifts">
<big><b>Surface.get_shifts</big></b><br><ul>
  <i>the bit shifts needed to convert between a color and a mapped integer</i><br>
  <tt>Surface.get_shifts(): return (R, G, B, A)</tt><br>
<p>Returns the pixel shifts need to convert between each color and a mapped integer. </p>
<p>This value is not needed for normal Pygame usage. </p>
<!--COMMENTS:Surface.get_shifts--> &nbsp;<br> 
<br></ul>


<a name="Surface.set_shifts">
<big><b>Surface.set_shifts</big></b><br><ul>
  <i>sets the bit shifts needed to convert between a color and a mapped integer</i><br>
  <tt>Surface.set_shifts((r,g,b,a)): return None</tt><br>
<p>This is not needed for normal Pygame usage. New in pygame 1.8.1 </p>
<!--COMMENTS:Surface.set_shifts--> &nbsp;<br> 
<br></ul>


<a name="Surface.get_losses">
<big><b>Surface.get_losses</big></b><br><ul>
  <i>the significant bits used to convert between a color and a mapped integer</i><br>
  <tt>Surface.get_losses(): return (R, G, B, A)</tt><br>
<p>Return the least significant number of bits stripped from each color in a mapped integer. </p>
<p>This value is not needed for normal Pygame usage. </p>
<!--COMMENTS:Surface.get_losses--> &nbsp;<br> 
<br></ul>


<a name="Surface.get_bounding_rect">
<big><b>Surface.get_bounding_rect</big></b><br><ul>
  <i>find the smallest rect containing data</i><br>
  <tt>Surface.get_bounding_rect(min_alpha = 1): return Rect</tt><br>
<p>Returns the smallest rectangular region that contains all the pixels in the surface that have an alpha value greater than or equal to the minimum alpha value. </p>
<p>This function will temporarily lock and unlock the Surface as needed. </p>
<p>New in pygame 1.8. </p>
<!--COMMENTS:Surface.get_bounding_rect--> &nbsp;<br> 
<br></ul>


<a name="Surface.get_view">
<big><b>Surface.get_view</big></b><br><ul>
  <i>return a view of a surface's pixel data.</i><br>
  <tt>Surface.get_view(kind='2'): return <view></tt><br>
<p>Return an object which exposes a surface's internal pixel buffer to a NumPy array. For now a custom object with an array struct interface is returned. A Python memoryview may be returned in the future. The buffer is writeable. </p>
<p>The kind argument is the length 1 string '2', '3', 'r', 'g', 'b', or 'a'. The letters are case insensitive; 'A' will work as well. The argument can be either a Unicode or byte (char) string. The default is '2'. </p>
<p>A kind '2' view is a (surface-width, surface-height) array of raw pixels. The pixels are surface bytesized unsigned integers. The pixel format is surface specific. The 3 byte unsigned integers of 24 bit surfaces are unlikely accepted by anything other than other Pygame functions. </p>
<p>'3' returns a (surface-width, surface-height, 3) view of <tt>RGB</tt> color components. Each of the red, green, and blue components are unsigned bytes. Only 24-bit and 32-bit surfaces are supported. The color components must be in either <tt>RGB</tt> or <tt>BGR</tt> order within the pixel. </p>
<p>'r' for red, 'g' for green, 'b' for blue, and 'a' for alpha return a (surface-width, surface-height) view of a single color component within a surface: a color plane. Color components are unsigned bytes. Both 24-bit and 32-bit surfaces support 'r', 'g', and 'b'. Only 32-bit surfaces with <tt>SRCALPHA</tt> support 'a'. </p>
<p>This method implicitly locks the Surface. The lock will be released, once the returned view object is deleted. </p>
<p>New in pygame 1.9.2. </p>
<!--COMMENTS:Surface.get_view--> &nbsp;<br> 
<br></ul>


<a name="Surface.get_buffer">
<big><b>Surface.get_buffer</big></b><br><ul>
  <i>acquires a buffer object for the pixels of the Surface.</i><br>
  <tt>Surface.get_buffer(): return BufferProxy</tt><br>
<p>Return a buffer object for the pixels of the Surface. The buffer can be used for direct pixel access and manipulation. </p>
<p>This method implicitly locks the Surface. The lock will be released, once the returned BufferProxy object is deleted. </p>
<p>New in pygame 1.8. </p>
<!--COMMENTS:Surface.get_buffer--> &nbsp;<br> 
<br></ul>
<br></ul>

</body></html>
