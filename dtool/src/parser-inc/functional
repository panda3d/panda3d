// Filename: functional
// Created by:  tobspr (01Nov16)
//
////////////////////////////////////////////////////////////////////
//
// PANDA 3D SOFTWARE
// Copyright (c) Carnegie Mellon University.  All rights reserved.
//
// All use of this software is subject to the terms of the revised BSD
// license.  You should have received a copy of this license along
// with this source code in a file named "LICENSE."
//
////////////////////////////////////////////////////////////////////

// This file, and all the other files in this directory, aren't
// intended to be compiled--they're just parsed by CPPParser (and
// interrogate) in lieu of the actual system headers, to generate the
// interrogate database.

#ifndef FUNCTIONAL_H
#define FUNCTIONAL_H

#include <stddef.h>

namespace std {

    // base (deprecated):
    template <class Arg, class Result> struct unary_function;
    template <class Arg1, class Arg2, class Result> struct binary_function;
 
    // reference_wrapper:
    template <class T> class reference_wrapper;
    template <class T> reference_wrapper<T> ref(T&) noexcept;
    template <class T> reference_wrapper<const T> cref(const T&) noexcept;
    template <class T> void ref(const T&&) = delete;
    template <class T> void cref(const T&&) = delete;
    template <class T> reference_wrapper<T> ref(reference_wrapper<T>) noexcept;
    template <class T> reference_wrapper<const T> cref(reference_wrapper<T>) noexcept;
 
    // arithmetic operations:
    template <class T> struct plus;
    template <class T> struct minus;
    template <class T> struct multiplies;
    template <class T> struct divides;
    template <class T> struct modulus;
    template <class T> struct negate;
 
    // comparisons:
    template <class T> struct equal_to;
    template <class T> struct not_equal_to;
    template <class T> struct greater;
    template <class T> struct less;
    template <class T> struct greater_equal;
    template <class T> struct less_equal;
 
    // logical operations:
    template <class T> struct logical_and;
    template <class T> struct logical_or;
    template <class T> struct logical_not;
 
    // bitwise operations:
    template <class T> struct bit_and;
    template <class T> struct bit_or;
    template <class T> struct bit_xor;
 
    // negators:
    template <class Predicate> class unary_negate;
    template <class Predicate>
        unary_negate<Predicate> 
        not1(const Predicate&);
    template <class Predicate>  class binary_negate;
    template <class Predicate>
        binary_negate<Predicate>
        not2(const Predicate&);
 
    // bind:
    template<class T> struct is_bind_expression;
    template<class T> struct is_placeholder;
    /*
    template<class  F, class... BoundArgs>
        unspecified bind(F&&, BoundArgs&&...);
    template<class  R, class F, class... BoundArgs>
        unspecified bind(F&&, BoundArgs&&...);
    */

    namespace placeholders {
        // M is the implementation-defined number of placeholders
        // (8 should be enough for interrogate)
        extern char _1;
        extern char _2;
        extern char _3;
        extern char _4;
        extern char _5;
        extern char _6;
        extern char _7;
        extern char _8;
    }
 
    // binders (deprecated):
    template <class Fn> class binder1st;
    template <class Fn, class T>
        binder1st<Fn> bind1st(const Fn&, const T&);
    template <class Fn> class binder2nd;
    template <class Fn, class T>
        binder2nd<Fn> bind2nd(const Fn&, const T&);
 
    // adaptors (deprecated):
    template <class Arg, class Result> class pointer_to_unary_function;
    template <class Arg, class Result>
        pointer_to_unary_function<Arg,Result> ptr_fun(Result (*)(Arg));
    template <class Arg1, class Arg2, class Result>
        class pointer_to_binary_function;
    template <class Arg1, class Arg2, class Result>
        pointer_to_binary_function<Arg1,Arg2,Result>
        ptr_fun(Result (*)(Arg1,Arg2));
 
    // adaptors (deprecated):
    template<class S, class T> class mem_fun_t;
    template<class S, class T, class A> class mem_fun1_t;
    template<class S, class T>
        mem_fun_t<S,T> mem_fun(S (T::*f)());
    template<class S, class T, class A>
        mem_fun1_t<S,T,A> mem_fun(S (T::*f)(A));
    template<class S, class T> class mem_fun_ref_t;
    template<class S, class T, class A> class mem_fun1_ref_t;
    template<class S, class T>
        mem_fun_ref_t<S,T> mem_fun_ref(S (T::*f)());
    template<class S, class T, class A>
        mem_fun1_ref_t<S,T,A> mem_fun_ref(S (T::*f)(A));
    template <class S, class T> class const_mem_fun_t;
    template <class S, class T, class A> class const_mem_fun1_t;
    template <class S, class T>
        const_mem_fun_t<S,T> mem_fun(S (T::*f)() const);
    template <class S, class T, class A>
        const_mem_fun1_t<S,T,A> mem_fun(S (T::*f)(A) const);
    template <class S, class T> class const_mem_fun_ref_t;
    template <class S, class T, class A> class const_mem_fun1_ref_t;
    template <class S, class T>
        const_mem_fun_ref_t<S,T> mem_fun_ref(S (T::*f)() const);
    template <class S, class T, class A>
        const_mem_fun1_ref_t<S,T,A> mem_fun_ref(S (T::*f)(A) const);
 
    // member function adaptors:
    /*
    template<class R, class T> void mem_fn(R T::*);
    template<class R, class T, class... Args>
        void mem_fn(R (T::*)(Args...));
    template<class R, class T, class... Args>
        void mem_fn(R (T::*)(Args...) const);
    template<class R, class T, class... Args>
        void mem_fn(R (T::*)(Args...) volatile);
    template<class R, class T, class... Args>
        void mem_fn(R (T::*)(Args...) const volatile);
    template<class R, class T, class... Args>
        void mem_fn(R (T::*)(Args...) &);
    template<class R, class T, class... Args>
        void mem_fn(R (T::*)(Args...) const &);
    template<class R, class T, class... Args>
        void mem_fn(R (T::*)(Args...) volatile &);
    template<class R, class T, class... Args>
        void mem_fn(R (T::*)(Args...) const volatile &);
    template<class R, class T, class... Args>
        void mem_fn(R (T::*)(Args...) &&);
    template<class R, class T, class... Args>
        void mem_fn(R (T::*)(Args...) const &&);
    template<class R, class T, class... Args>
        void mem_fn(R (T::*)(Args...) volatile &&);
    template<class R, class T, class... Args>
        void mem_fn(R (T::*)(Args...) const volatile &&);
    */

    // polymorphic function wrappers:
    class bad_function_call;
    // template<typename T> class function; // undefined
    /*
    template<class R, class... ArgTypes> class function<R(ArgTypes...)>;
    template<class R, class... ArgTypes>
        void swap(function<R(ArgTypes...)>&, function<R(ArgTypes...)>&);
    template<class R, class... ArgTypes>
        bool operator==(const function<R(ArgTypes...)>&, nullptr_t);
    template<class R, class... ArgTypes>
        bool operator==(nullptr_t, const function<R(ArgTypes...)>&);
    template<class R, class... ArgTypes>
        bool operator!=(const function<R(ArgTypes...)>&, nullptr_t);
    template<class R, class... ArgTypes>
        bool operator!=(nullptr_t, const function<R(ArgTypes...)>&);
    */

    // hash function base template:
    template <class T> struct hash;
 
    // Hash function specializations
    template <> struct hash<bool>;
    template <> struct hash<char>;
    template <> struct hash<signed char>;
    template <> struct hash<unsigned char>;
    template <> struct hash<char16_t>;
    template <> struct hash<char32_t>;
    template <> struct hash<wchar_t>;
    template <> struct hash<short>;
    template <> struct hash<unsigned short>;
    template <> struct hash<int>;
    template <> struct hash<unsigned int>;
    template <> struct hash<long>;
    template <> struct hash<long long>;
    template <> struct hash<unsigned long>;
    template <> struct hash<unsigned long long>;
    template <> struct hash<float>;
    template <> struct hash<double>;
    template <> struct hash<long double>;
    template<class T> struct hash<T*>;
     
    template <class T> class reference_wrapper {
    public :
        // types
        typedef T type;
        typedef /*Return type of T*/     result_type;          // not always defined
        typedef /*Single argument of T*/ argument_type;        // not always defined
        typedef /*1st argument of T*/    first_argument_type;  // not always defined
        typedef /*2nd argument of T*/    second_argument_type; // not always defined
     
        // construct/copy/destroy
        reference_wrapper(T&) noexcept;
        reference_wrapper(T&&) = delete;
     
        // do not bind to temporary objects
        reference_wrapper(const reference_wrapper<T>& x) noexcept;
     
        // assignment
        reference_wrapper& operator=(const reference_wrapper<T>& x) noexcept;
     
        // access
        operator T& () const noexcept;
        T& get() const noexcept;
     
        // invocation
        /*
        template <class... ArgTypes>
            typename result_of<T&(ArgTypes&&...)>::type
            operator() (ArgTypes&&...) const;
        */
    };

    template<class T> struct is_bind_expression { static bool value = true; };
    // : integral_constant<bool, true> {};

    class bad_function_call : public std::exception {
    public:
        // constructor:
        bad_function_call() noexcept;
    };

    // template<class> class function; // undefined
     
    template<class R /* , class... ArgTypes */ >
    class function {
    public:
        typedef R result_type;      
        // typedef T1 argument_type;       //  iff sizeof...(ArgTypes) == 1 and
                                        //  the type in ArgTypes is T1
        // typedef T1 first_argument_type; //  iff sizeof...(ArgTypes) == 2 and
                                        //  ArgTypes contains T1 and T2
        // typedef T2 second_argument_type;//  iff sizeof...(ArgTypes) == 2 and
                                        //  ArgTypes contains T1 and T2
     
        // construct/copy/destroy:
        function() noexcept;
        function(nullptr_t) noexcept;
        function(const function&);
        function(function&&);
     
        template<class F> function(F);
        // template<class A> function(allocator_arg_t, const A&) noexcept;
        // template<class A> function(allocator_arg_t, const A&, nullptr_t) noexcept;
        // template<class A> function(allocator_arg_t, const A&, const function&);
        // template<class A> function(allocator_arg_t, const A&, function&&);
        // template<class F, class A> function(allocator_arg_t, const A&, F);
     
        function& operator=(const function&);
        function& operator=(function&&);
        function& operator=(nullptr_t);
        template<class F> function& operator=(F&&);
        template<class F> function& operator=(reference_wrapper<F>) noexcept;
     
        ~function();
     
        // function modifiers:
        void swap(function&) noexcept;
        template<class F, class A> void assign(F&&, const A&);
     
        // function capacity:
        explicit operator bool() const noexcept;
     
        // function invocation:
        // R operator()(ArgTypes...) const;
     
        // function target access:
        // const std::type_info& target_type() const noexcept;
        template <typename T>       T* target() noexcept;
        template <typename T> const T* target() const noexcept;
     
    };

}


#endif
